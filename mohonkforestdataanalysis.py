# -*- coding: utf-8 -*-
"""MohonkForestDataAnalysis.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1bDraY5nCaQHXTW5FWhB2zUhpe2gZdmIG
"""

#Most Current Code Block!

#Code Block which contains functions to display the inaccuracies, compare 2018 & 2022 plots, display 21/22 plots, and more.?

#Import libraries
import pandas as pd
import numpy as np
import math
from matplotlib import pyplot as plt
from collections import defaultdict
import statistics
import seaborn

url = 'https://raw.githubusercontent.com/IsaacGordin/MohonkForestData/main/TreeDat.csv'
treedat = pd.read_csv(url)
fc = math.pi/(4*144) # value is used to convert diameter(inches) to area(feet), Forester's Constant
plotAreaSquareMeters = 225 #Value given to me by Megan Napoli, 15x15 meter plots
plotAreaAcres = plotAreaSquareMeters/4047

#This function will add: dbh in inches, basal area in square feet, and expansion factor to the dataframe
#The expansion factor is used to create a trees per acre value. The plots are ~ 1/18 acres, so one tree per plot represents 18 trees per acre
def colAdd(df):
  df['DBHInches'] = df['DBH']/2.54
  df['ba'] = (df['DBHInches']**2)*fc
  df['ef'] = 1/plotAreaAcres
  return df
treedat = colAdd(treedat)

#This function returns a dataframe of data by plot. The data includes the DBH/ba sum and avg, tree count, and forest type, and trees per acre.
def plotAverages(df, year):
  if(year == 2018):
    df = df[df['Year'] == 2018]
  else:
    df = df[df['Year'] > 2018]
  plotCount = df['Plot'].nunique()
  plotList = list(range(1,plotCount+1)) #Create empty lists to populate with data
  treeCount = [0]*plotCount
  DBHSum = [0]*plotCount
  QMD = [0]*plotCount
  baSum = [0]*plotCount
  DBHAvg = [0]*plotCount
  baAvg = [0]*plotCount
  baa = [0]*plotCount
  tpa = [0]*plotCount
  forestType = ['']*plotCount
  for index, row in df.iterrows(): #Iterate over dataset
    if(math.isnan(row['DBH']) | math.isnan(row['Tree_#'])): #Check that the tree is there
      continue
    DBHSum[row['Plot']-1] += row['DBHInches'] #Increment values
    baSum[row['Plot']-1] += row['ba']
    treeCount[row['Plot']-1] += 1
    forestType[row['Plot']-1] = row['Plot.Type']
  for i in plotList:
    DBHAvg[i-1] = DBHSum[i-1]/treeCount[i-1] #Average values
    baAvg[i-1] = baSum[i-1]/treeCount[i-1]
    QMD[i-1] = math.sqrt(baAvg[i-1]/fc)
    baa[i-1] = baSum[i-1] * (1/plotAreaAcres)
    tpa[i-1] = treeCount[i-1] * (1/plotAreaAcres)

  returnTable = pd.DataFrame({'Plot': plotList, 'TreeCount': treeCount, 'DBHSum': DBHSum, 'DBHAvg': DBHAvg, 'QMD': QMD,
                              'baSum': baSum, 'baAvg': baAvg,  'baa': baa, 'tpa': tpa, 'ForestType': forestType})
  return returnTable

#This function will show the change in diameter sum from the plots that were established in 2018 and resampled in 2022
def plotDelta(dataFrame):
  plotCount = dataFrame[dataFrame['Year']==2018]['Plot'].nunique()#Count of plots sampled in 2018
  dat2018 = plotAverages(dataFrame, 2018)
  dat2022 = plotAverages(dataFrame, 2020)
  dat2022 = dat2022[dat2022['Plot'] <= plotCount]
  deltaArr = [0]*plotCount
  for i in range(len(dat2018['DBHSum'])):
    deltaArr[i] = dat2022['DBHSum'][i] - dat2018['DBHSum'][i]
  return deltaArr

#This method creates a new data frame of trees that were sampled in 2018 and 2022 where the diameters are valid and accurate
#The checks we do include, does tree exist, does diameter data exist for both years, if diameter decreases by a large amount, if tree is dead, discard.
def deltaValid(df):
  plotCount = df[df['Year']==2018]['Plot'].nunique()
  plot, treenum, dbh18List, dbh22List, deltaList, species18List, species22List, status18List, status22List, forestTypeList = [],[],[],[],[],[],[],[],[],[]
  for i in range(1,(plotCount+1),1): #I represents the plot number
    for j in range(1, (len(df[df['Plot'] == i])+1),1): #J represents the tree number
      row18 = df[(df['Plot'] == i) & (df['Tree_#'] == j) & (df['Year'] == 2018)] #Unique row val
      row22 = df[(df['Plot'] == i) & (df['Tree_#'] == j) & (df['Year'] == 2022)]
      if(row18.empty | row22.empty): #.empty checks if data exists for the tree coordinates. ie, tree added in 22 doesn't exist in 18
        continue
      dbh18 = row18['DBHInches']
      dbh22 = row22['DBHInches']
      species18 = row18['Species'].values[0] #gets rid of all the noise, ie, 577 White pine Name: Species, dtype: object --> White Pine
      species22 = row22['Species'].values[0]
      status18 = str(row18['Status'].values[0])
      status22 = str(row22['Status'].values[0])
      forestType = row18['Plot.Type'].values[0]
      if(status18.__contains__('D') | status22.__contains__('D')): #This catches for if the tree is dead. Can't measure growth if tree died
        continue
      if(math.isnan(dbh18) | math.isnan(dbh22)):
        continue
      dbh18 = float(dbh18) # see .values[0], same purpose
      dbh22 = float(dbh22)
      decreasePercentage = .9
      delta = dbh22 - dbh18
      if((decreasePercentage*dbh18) > dbh22): #If the diameter decreased and it decreased by more than 10% of original diameter
        continue
      plot.append(i), treenum.append(j), dbh18List.append(dbh18), dbh22List.append(dbh22), deltaList.append(delta), species18List.append(species18)
      species22List.append(species22), status18List.append(status18), status22List.append(status22), forestTypeList.append(forestType)
  cleanedDat = pd.DataFrame({'Plot': plot, 'TreeNum': treenum, 'DBH18': dbh18List, 'DBH22': dbh22List, 'DeltaDBH': deltaList,
                'Species': species18List, 'Species22': species22List, 'Status18': status18List, 'Status22': status22List, 'ForestType': forestTypeList})
  return cleanedDat

#This function returns a dataframe of clean data from 21/22. Clean data is considered to have a non na number for plot, treenum, and DBH
def cleanModernDataTable(df):
  df = df[df['Year'] > 2018]
  plot, treenum, dbhList, baList, efList, speciesList, statusList, forestTypeList = [],[],[],[],[],[],[],[]
  for index, row in df.iterrows():
    if((math.isnan(row['Plot'])) | (math.isnan(row['Tree_#'])) | (math.isnan(row['DBH']))):
      continue
    plot.append(row['Plot'])
    treenum.append(row['Tree_#'])
    dbhList.append(row['DBHInches'])
    baList.append(row['ba'])
    efList.append(row['ef'])
    speciesList.append(row['Species'])
    statusList.append(row['Status'])
    forestTypeList.append(row['Plot.Type'])
    returnTable = pd.DataFrame({'Plot': plot, 'TreeNum': treenum, 'DBHInches': dbhList, 'ba': baList, 'ef': efList,
                'Species': speciesList, 'Status': statusList,'ForestType': forestTypeList})
  return returnTable

#This function will take a cleaned dataset and show measurement by type.
def plotter(df, xAxis, xAction, yAxis):
  dataList = list(set(df[yAxis])) #Set of the yAxis parameters become the keys
  SumDict = dict.fromkeys(dataList,0) #The 0 initializes the list at 0
  CountDict = dict.fromkeys(dataList,0)
  AvgDict = dict.fromkeys(dataList,0)
  for index, row in df.iterrows():
    yVal = row[yAxis] #The will represent the individual value of the ie, species
    xSum = float(row[xAxis])
    SumDict[yVal] += xSum #Increment the DBH sum,
    CountDict[yVal] += 1 #Increment the count

  for key in SumDict: #Create the averages
    AvgDict[key] = SumDict[key] / CountDict[key]

  cd = defaultdict(list) #This combines the lists
  for d in (SumDict, CountDict, AvgDict):
    for key, value in d.items():
      cd[key].append(value)

  values = [elem[xAction] for elem in cd.values()] #The xAxis parameter is used here to determine sum, count, or average

  fig, ax = plt.subplots()
  y_pos = np.arange(len(cd.keys()))
  ax.barh(y_pos, values, align='center')
  ax.set_yticks(y_pos, labels=cd.keys())
  ax.invert_yaxis()  # labels read top-to-bottom
  ax.set_xlabel(xAxis)
  ax.set_title('')


modDat = cleanModernDataTable(treedat)
changeDat = deltaValid(treedat)
#plotter(changeDat, 'DeltaDBH', 0, 'Plot')
hemlock = modDat[(modDat['ForestType'] == 'Hemlock') | (modDat['ForestType'] == 'Hemlock-BB') | (modDat['ForestType'] == 'HemlockHardwood-BB')]
ash = modDat[modDat['ForestType'] == 'Ash']
burn = modDat[modDat['ForestType'] == 'Burn']
pp = modDat[modDat['ForestType'] == 'PitchPine-BB']
chest = modDat[(modDat['ForestType'] == 'ChestnutOak-BB') | (modDat['ForestType'] == 'Burn')]
oakhick = modDat[modDat['ForestType'] == 'OakHickory-BB']
#display(hemlock)
#plotter(chest, 'ba', 0, 'Species')
#plotter(oakhick, 'DBHInches', 2, 'Species')
#plotter(plotAverages(treedat, 2019), 'QMD', 2, 'ForestType')

#display(modDat)
dataList = list(set(modDat['Plot'])) #Set of the yAxis parameters become the keys
baSum = dict.fromkeys(dataList,0)
baCount = dict.fromkeys(dataList,0)
QMDDict = dict.fromkeys(dataList,0)
tpaSum = dict.fromkeys(dataList,0)
tpaCount = dict.fromkeys(dataList,0)
tpaDict = dict.fromkeys(dataList,0)
ForestTypeDict = dict.fromkeys(dataList,0)
for index, row in modDat.iterrows():
  plotNum = row['Plot'] #The will represent the individual value of the ie, species
  baSum[plotNum] += row['ba']
  baCount[plotNum] += 1
  tpaDict[plotNum] += row['ef']
  ForestTypeDict[plotNum] = row['ForestType']

for key in QMDDict: #Create the averages
  QMDDict[key] = math.sqrt((baSum[key] / baCount[key])/fc)

data2 = [QMDDict, tpaDict]
#d2 = pd.DataFrame(data = {'Plot': QMDDict.keys(), 'QMD': QMDDict.values(), 'tpa': tpaDict.values(), 'ForestType': ForestTypeDict.values()})
#display(d2)

#display(data)
dfx = pd.DataFrame.from_dict(data2).transpose()
dfx.columns = ['QMD', 'tpa']
#display(dfx)
#dfx = pd.DataFrame([QMDDict, tpaDict])
#dfx = dfx.set_index('Species', inplace=True)
#fg = seaborn.FacetGrid(data=d2)#, hue = 'ForestType')
#fg.map(plt.scatter, 'QMD', 'tpa').add_legend()

#plotter(deltaValid(treedat), 'DeltaDBH', 0, 'Plot')
#display(deltaValid(treedat))


#plt.scatter(plotAverages(treedat,2019)['QMD'], plotAverages(treedat,2019)['tpa'])
fg = seaborn.FacetGrid(data=plotAverages(treedat,2019), hue='ForestType')
fg.map(plt.scatter, 'QMD', 'tpa').add_legend()

"""This text block will be a place to keep values that I calculated and graphs that look good. This will evolve.\
Average forest level values from 21/22 data. \
Plots Sampled: 52 \
Basal Area per Acre: 161.6 sq ft.\
Trees per Acre: 229.3 \
Quadratic Mean Diameter at Breast Height: 11.5 inches \
Arithmetic Mean Diameter at Breast Height: 10.3 inches \
Average forest level values from 2018 data. \
Plots Sampled: 24 \
Basal Area per Acre: 175.4 sq ft.\
Trees per Acre: 226.3 \
Quadratic Mean Diameter at Breast Height: 12.0 inches \
Arithmetic Mean Diameter at Breast Height: 10.8 inches \
Below displays a scatter plot where the x axis is QMD and the y axis is tree per acre: \
![QMDTPAGraph.png](data:image/png;base64,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)

"""

#Helper Function
def dataCleaner(df):#This function will create a list of plot and tree numbers where there are inaccuracies
#We define inaccuracies as a change in species name or decrease in tree diameter
#We only need to compare the plots sampled in 2018 and 2022
  plotNumbers = []
  treeNumbers = []
  reason = []
  df = df[(df['Year']==2018) | (df['Year'] == 2022)]
  plotCount = df[df['Year']==2018]['Plot'].nunique()#Count of plots sampled in 2018
  for i in range(1,(plotCount+1),1):
    for j in range(1, (len(df[(df['Plot'] == i) & (df['Year'] == 2018)])+1),1):
      #Get index of Plot = i, TreeNum = j, Year = 2018/2022, first check if exists
      if(df[(df['Year'] == 2018) & (df['Plot'] == i) & (df['Tree_#'] == j)].empty |
         df[(df['Year'] == 2022) & (df['Plot'] == i) & (df['Tree_#'] == j)].empty):
        plotNumbers.append(i)
        treeNumbers.append(j)
        reason.append('NA index')
        continue
      index2018 = df.index[(df['Plot']==i) & (df['Tree_#']==j) & (df['Year']==2018)][0]
      index2022 = df.index[(df['Plot']==i) & (df['Tree_#']==j) & (df['Year']==2022)][0]
      #Complete a series of checks
      if(math.isnan(df['DBH'][index2018]) | math.isnan(df['DBH'][index2022])):
          plotNumbers.append(i)
          treeNumbers.append(j)
          reason.append('NA DBH')
          continue
      if(df['DBH'][index2018] > df['DBH'][index2022]):
        plotNumbers.append(i)
        treeNumbers.append(j)
        reason.append('Tree Shrank')
        continue
      #Create some catch for a large increase
      if(pd.isnull(df['Species'][index2018]) | pd.isnull(df['Species'][index2022])):
        plotNumbers.append(i)
        treeNumbers.append(j)
        reason.append('NA species')
        continue
      if(df['Species'][index2018] != df['Species'][index2022]):
        plotNumbers.append(i)
        treeNumbers.append(j)
        reason.append('Different Species')
        continue
  coordinates = pd.DataFrame({'Plot#': plotNumbers, 'Tree#': treeNumbers, 'Reason': reason})
  return coordinates

#Code block for change over time forest data analysis. There will be some overlap, but, oh well

#This python script will be to clean the data and analyze forest data from Mohonk Preserve

#Final end product goal: https://www.uvm.edu/femc/nefin/datavisualize, something like this

#Import libraries
import pandas as pd
import numpy as np
import math
from matplotlib import pyplot as plt
from collections import defaultdict

url = 'https://raw.githubusercontent.com/IsaacGordin/MohonkForestData/main/TreeDat.csv'
treedat = pd.read_csv(url)
fc = math.pi/(4*144) # value is used to convert diameter(inches) to area(feet), Forester's Constant
plotAreaSquareMeters = 225 #Value given to me by Megan Napoli, 15x15 meter plots
plotAreaAcres = plotAreaSquareMeters/4047


#This function will add: dbh in inches, basal area in square feet, and expansion factor to the dataframe
#The expansion factor is used to create a trees per acre value. The plots are ~ 1/18 acres, so one tree per plot represents 18 trees per acre
def colAdd(df):
  df['DBHInches'] = df['DBH']/2.54
  df['ba'] = (df['DBHInches']**2)*fc
  df['ef'] = 1/plotAreaAcres
  return df

treedat = colAdd(treedat)

#This function returns a dataframe of data by plot. The data includes the DBH/ba sum and avg, tree count, and forest type, and trees per acre
def plotAverages(df, year):
  if(year == 2018):
    df = df[df['Year'] == 2018]
  else:
    df = df[df['Year'] > 2018]
  plotCount = df['Plot'].nunique()
  plotList = list(range(1,plotCount+1)) #Create empty lists to populate with data
  treeCount = [0]*plotCount
  DBHSum = [0]*plotCount
  baSum = [0]*plotCount
  DBHAvg = [0]*plotCount
  baAvg = [0]*plotCount
  tpa = [0]*plotCount
  forestType = ['']*plotCount
  for index, row in df.iterrows(): #Iterate over dataset
    if(math.isnan(row['DBH']) | math.isnan(row['Tree_#'])): #Check that the tree is there
      continue
    DBHSum[row['Plot']-1] += row['DBH'] #Increment values
    baSum[row['Plot']-1] += row['ba']
    treeCount[row['Plot']-1] += 1
    forestType[row['Plot']-1] = row['Plot.Type']
    tpa[row['Plot']-1] += row['ef']

  for i in plotList:
    DBHAvg[i-1] = DBHSum[i-1]/treeCount[i-1] #Average values
    baAvg[i-1] = baSum[i-1]/treeCount[i-1]

  returnTable = pd.DataFrame({'Plot': plotList, 'DBHSum': DBHSum, 'baSum': baSum, 'TreeCount': treeCount,
                              'DBHAvg': DBHAvg, 'baAvg': baAvg, 'tpa': tpa, 'ForestType': forestType})
  return returnTable


def dataCleaner(dataFrame):#This function will create a list of plot and tree numbers where there are inaccuracies
#We define inaccuracies as a change in species name or decrease in tree diameter
#We only need to compare the plots sampled in 2018 and 2022
  plotNumbers = []
  treeNumbers = []
  reason = []
  plotCount = dataFrame[dataFrame['Year']==2018]['Plot'].nunique()#Count of plots sampled in 2018
  for i in range(1,(plotCount+1),1):
    for j in range(1, (len(dataFrame[(dataFrame['Plot'] == i) & (dataFrame['Year'] == 2018)])+1),1):
      #Get index of Plot = i, TreeNum = j, Year = 2018/2022, first check if exists
      if(dataFrame[(dataFrame['Year'] == 2018) & (dataFrame['Plot'] == i) & (dataFrame['Tree_#'] == j)].empty |
         dataFrame[(dataFrame['Year'] == 2022) & (dataFrame['Plot'] == i) & (dataFrame['Tree_#'] == j)].empty):
        plotNumbers.append(i)
        treeNumbers.append(j)
        reason.append('NA index')
        print('NA index at Plot:', i, 'Tree:', j)
        continue
      index2018 = dataFrame.index[(dataFrame['Plot']==i) & (dataFrame['Tree_#']==j) & (dataFrame['Year']==2018)][0]
      index2022 = dataFrame.index[(dataFrame['Plot']==i) & (dataFrame['Tree_#']==j) & (dataFrame['Year']==2022)][0]
      #Complete a series of checks
      if(math.isnan(dataFrame['DBH'][index2018]) | math.isnan(dataFrame['DBH'][index2022])):
          plotNumbers.append(i)
          treeNumbers.append(j)
          reason.append('NA DBH')
          print('NA DBH at Plot:', i, 'Tree:', j)
          continue
      if(pd.isnull(dataFrame['Species'][index2018]) | pd.isnull(dataFrame['Species'][index2022])):
        plotNumbers.append(i)
        treeNumbers.append(j)
        reason.append('NA species')
        print('NA Species at Plot:', i, 'Tree:', j)
        continue
      if(dataFrame['DBH'][index2018] > dataFrame['DBH'][index2022]):
        plotNumbers.append(i)
        treeNumbers.append(j)
        reason.append('Tree Shrank')
        print('Tree shrank at Plot:', i, 'Tree:', j)
        print('2018 DBH:', dataFrame['DBH'][index2018], '2022 DBH:', dataFrame['DBH'][index2022])
      #Create some catch for a large increase
      if(dataFrame['Species'][index2018] != dataFrame['Species'][index2022]):
        plotNumbers.append(i)
        treeNumbers.append(j)
        reason.append('Different Species')
        print('Different Species at Plot:', i, 'Tree:', j)
        print('2018 Species:', dataFrame['Species'][index2018], '2022 Species:', dataFrame['Species'][index2022])
  coordinates = {'Plot#': plotNumbers, 'Tree#': treeNumbers, 'Reason': reason}
  return coordinates


inaccuracies = pd.DataFrame(dataCleaner(treedat))
#display(pd.DataFrame(inaccuracies))
inaccuracies.to_csv('inaccuracies.csv')


#This function will show the change in diameter sum from the plots that were established in 2018 and resampled in 2022
def plotDelta(dataFrame):
  plotCount = dataFrame[dataFrame['Year']==2018]['Plot'].nunique()#Count of plots sampled in 2018
  dat2018 = plotAverages(dataFrame, 2018)
  dat2022 = plotAverages(dataFrame, 2020)
  dat2022 = dat2022[dat2022['Plot'] <= plotCount]
  deltaArr = [0]*plotCount
  for i in range(len(dat2018['DBHSum'])):
    deltaArr[i] = dat2022['DBHSum'][i] - dat2018['DBHSum'][i]
  return deltaArr

#This method creates a new data frame of trees that were sampled in 2018 and 2022 where the diameters are valid and accurate
#The checks we do include, does tree exist, does diameter data exist for both years, if diameter decreases by a large amount, if tree is dead, discard.
def deltaValid(dataFrame):
  plotCount = dataFrame[dataFrame['Year']==2018]['Plot'].nunique()#Plot count for 2018 and 2022
  col = ['Plot', 'Tree', 'DBH18', 'DBH22', 'DeltaDBH', 'Species18', 'Species22', 'Status18', 'Status22', 'ForestType'] #Column Array for the return function
  cleanedDat = pd.DataFrame(columns = col) #DataFrame that we will return
  for i in range(1,(plotCount+1),1): #I represents the plot number
    for j in range(1, (len(dataFrame[dataFrame['Plot'] == i])+1),1): #J represents the tree number
      row18 = dataFrame[(dataFrame['Plot'] == i) & (dataFrame['Tree_#'] == j) & (dataFrame['Year'] == 2018)] #Unique row val
      row22 = dataFrame[(dataFrame['Plot'] == i) & (dataFrame['Tree_#'] == j) & (dataFrame['Year'] == 2022)]
      if(row18.empty | row22.empty): #.empty checks if data exists for the tree coordinates. ie, tree added in 22 doesn't exist in 18
        continue
      dbh18 = row18['DBH']
      dbh22 = row22['DBH']
      species18 = row18['Species'].values[0] #gets rid of all the noise, ie, 577 White pine Name: Species, dtype: object --> White Pine
      species22 = row22['Species'].values[0]
      status18 = str(row18['Status'].values[0])
      status22 = str(row22['Status'].values[0])
      forestType = row18['Plot.Type'].values[0]
      if(status18.__contains__('D') | status22.__contains__('D')): #This catches for if the tree is dead. Can't measure growth if tree died
        continue
      if(math.isnan(dbh18) | math.isnan(dbh22)):
        continue
      dbh18 = float(dbh18) # see .values[0], same purpose
      dbh22 = float(dbh22)
      decreasePercentage = .9
      delta = dbh22 - dbh18
      if((decreasePercentage*dbh18) > dbh22): #If the diameter decreased and it decreased by more than 10% of original diameter
        continue
      cleanedDat.loc[len(cleanedDat.index)] = [i, j, dbh18, dbh22, delta, species18, species22, status18, status22, forestType]#add data if passes all checks
  return cleanedDat

def deltaValid2(df):
  plotCount = df[df['Year']==2018]['Plot'].nunique()
  plot, treenum, dbh18List, dbh22List, deltaList, species18List, species22List, status18List, status22List, forestTypeList = [],[],[],[],[],[],[],[],[],[]
  for i in range(1,(plotCount+1),1): #I represents the plot number
    for j in range(1, (len(df[df['Plot'] == i])+1),1): #J represents the tree number
      row18 = df[(df['Plot'] == i) & (df['Tree_#'] == j) & (df['Year'] == 2018)] #Unique row val
      row22 = df[(df['Plot'] == i) & (df['Tree_#'] == j) & (df['Year'] == 2022)]
      if(row18.empty | row22.empty): #.empty checks if data exists for the tree coordinates. ie, tree added in 22 doesn't exist in 18
        continue
      dbh18 = row18['DBH']
      dbh22 = row22['DBH']
      species18 = row18['Species'].values[0] #gets rid of all the noise, ie, 577 White pine Name: Species, dtype: object --> White Pine
      species22 = row22['Species'].values[0]
      status18 = str(row18['Status'].values[0])
      status22 = str(row22['Status'].values[0])
      forestType = row18['Plot.Type'].values[0]
      if(status18.__contains__('D') | status22.__contains__('D')): #This catches for if the tree is dead. Can't measure growth if tree died
        continue
      if(math.isnan(dbh18) | math.isnan(dbh22)):
        continue
      dbh18 = float(dbh18) # see .values[0], same purpose
      dbh22 = float(dbh22)
      decreasePercentage = .9
      delta = dbh22 - dbh18
      if((decreasePercentage*dbh18) > dbh22): #If the diameter decreased and it decreased by more than 10% of original diameter
        continue
      plot.append(i), treenum.append(j), dbh18List.append(dbh18), dbh22List.append(dbh22), deltaList.append(delta), species18List.append(species18)
      species22List.append(species22), status18List.append(status18), status22List.append(status22), forestTypeList.append(forestType)
  cleanedDat = pd.DataFrame({'Plot': plot, 'TreeNum': treenum, 'DBH18': dbh18List, 'DBH22': dbh22List, 'DeltaDBH': deltaList,
                'Species': species18List, 'Species22': species22List, 'Status18': status18List, 'Status22': status22List, 'ForestType': forestTypeList})
  return cleanedDat

#display(deltaValid2(treedat))


def modernDataTable(df):
  col = ['Plot', 'Tree', 'DBH', 'Species', 'Status', 'ForestType'] #Column Array for the return function
  returnTable = pd.DataFrame(columns = col)
  for index, row in df.iterrows():
    if(row['Year'] == 2018):
      continue
    if((math.isnan(row['Plot'])) | (math.isnan(row['Tree_#'])) | (math.isnan(row['DBH']))):
      continue
    plot = row['Plot']
    tree = row['Tree_#']
    dbh = row['DBH']
    species = row['Species'] #gets rid of all the noise, ie, 577 White pine Name: Species, dtype: object --> White Pine
    status = row['Status']
    forestType = row['Plot.Type']
    dbh = float(dbh)
    returnTable.loc[len(returnTable.index)] = [plot, tree, dbh, species, status, forestType]#add data if passes all checks
  return returnTable

#Let's try to create a plot from inputs. Parameters: DataFrame, x axis(sum, count, avg), y axis(Species18, Plot, ForestType)
#xAxis == 0, returns the sum, 1 -> count, 2 -> average
#yAxis, Species18, Species22, Plot, ForestType
#If I want to specify a certain type of forest type or plot# in the
def plotter(df, xAxis, yAxis):
  #First, clean the data set
  cleanDataSet = deltaValid(df)
  #cleanDataSet = cleanDataSet[cleanDataSet['Plot']==1]

  dataList = list(set(cleanDataSet[yAxis])) #Set of the yAxis parameters become the keys
  SumDict = dict.fromkeys(dataList,0) #The 0 initializes the list at 0
  CountDict = dict.fromkeys(dataList,0)
  AvgDict = dict.fromkeys(dataList,0)
  for index, row in cleanDataSet.iterrows():
    yVal = row[yAxis] #The will represent the individual value of the ie, species
    delta = float(row['DeltaDBH'])
    SumDict[yVal] += delta #Increment the DBH sum,
    CountDict[yVal] += 1 #Increment the count

  for key in SumDict: #Create the averages
    AvgDict[key] = SumDict[key] / CountDict[key]

  cd = defaultdict(list) #This combines the lists
  for d in (SumDict, CountDict, AvgDict):
    for key, value in d.items():
      cd[key].append(value)

  values = [elem[xAxis] for elem in cd.values()] #The xAxis parameter is used here to determine sum, count, or average

  fig, ax = plt.subplots()
  y_pos = np.arange(len(cd.keys()))
  ax.barh(y_pos, values, align='center')
  ax.set_yticks(y_pos, labels=cd.keys())
  ax.invert_yaxis()  # labels read top-to-bottom
  ax.set_xlabel(xAxis)
  ax.set_title('')


output = modernDataTable(treedat)
#plotter(treedat, 0, 'Species18')
#display(output)

#Code block for current forest data analysis

#This python script will be to clean the data and analyze forest data from Mohonk Preserve

#Final end product goal: https://www.uvm.edu/femc/nefin/datavisualize, something like this

#Import libraries
import pandas as pd
import numpy as np
import math
from matplotlib import pyplot as plt
from collections import defaultdict

url = 'https://raw.githubusercontent.com/IsaacGordin/MohonkForestData/main/TreeDat.csv'
treedat = pd.read_csv(url)
fc = math.pi/(4*144) # value is used to convert diameter(inches) to area(feet), Forester's Constant
plotAreaSquareMeters = 225 #Value given to me by Megan Napoli, 15x15 meter plots
plotAreaAcres = plotAreaSquareMeters/4047

#This function will add: dbh in inches, basal area in square feet, and expansion factor to the dataframe
#The expansion factor is used to create a trees per acre value. The plots are ~ 1/18 acres, so one tree per plot represents 18 trees per acre
def colAdd(df):
  df['DBHInches'] = df['DBH']/2.54
  df['ba'] = (df['DBHInches']**2)*fc
  df['ef'] = 1/plotAreaAcres
  return df

treedat = colAdd(treedat)

#This function returns a dataframe of data by plot. The data includes the DBH/ba sum and avg, tree count, and forest type, and trees per acre
def modernPlotAverages(df):
  df = df[df['Year'] > 2018] #We only want current data
  plotCount = df['Plot'].nunique()
  plotList = list(range(1,plotCount+1)) #Create empty lists to populate with data
  treeCount = [0]*plotCount
  DBHSum = [0]*plotCount
  baSum = [0]*plotCount
  DBHAvg = [0]*plotCount
  baAvg = [0]*plotCount
  tpa = [0]*plotCount
  forestType = ['']*plotCount
  for index, row in df.iterrows(): #Iterate over dataset
    if(math.isnan(row['DBH']) | math.isnan(row['Tree_#'])): #Check that the tree is there
      continue
    DBHSum[row['Plot']-1] += row['DBH'] #Increment values
    baSum[row['Plot']-1] += row['ba']
    treeCount[row['Plot']-1] += 1
    forestType[row['Plot']-1] = row['Plot.Type']
    tpa[row['Plot']-1] += row['ef']

  for i in plotList:
    DBHAvg[i-1] = DBHSum[i-1]/treeCount[i-1]
    baAvg[i-1] = baSum[i-1]/treeCount[i-1]

  returnTable = pd.DataFrame({'Plots': plotList, 'DBHSum': DBHSum, 'baSum': baSum, 'TreeCount': treeCount,
                              'DBHAvg': DBHAvg, 'baAvg': baAvg, 'tpa': tpa, 'ForestType': forestType})
  return returnTable

#This function returns a dataframe of clean data from 21/22
def cleanModernDataTable(df):
  df = df[df['Year'] > 2018]
  plot, treenum, dbhList, baList, efList, speciesList, statusList, forestTypeList = [],[],[],[],[],[],[],[]
  for index, row in df.iterrows():
    if((math.isnan(row['Plot'])) | (math.isnan(row['Tree_#'])) | (math.isnan(row['DBH']))):
      continue
    plot.append(row['Plot'])
    treenum.append(row['Tree_#'])
    dbhList.append(row['DBHInches'])
    baList.append(row['ba'])
    efList.append(row['ef'])
    speciesList.append(row['Species'])
    statusList.append(row['Status'])
    forestTypeList.append(row['Plot.Type'])
    returnTable = pd.DataFrame({'Plot': plot, 'TreeNum': treenum, 'DBHInches': dbhList, 'ba': baList, 'ef': efList,
                'Species': speciesList, 'Status': statusList,'ForestType': forestTypeList})
  return returnTable
display(cleanModernDataTable(treedat))

#This function is to generalize the cleaned forest data into a simple bar graph.
#df is the dataFrame(treedat)
#xAxis is the value we will sum, count or average, DBH, ba, ef
#action is the statistic we will derive, sum, count, average, 0->sum, 1->count, 2->average
#yAxis is what the action is done over, plots, forest type, tree status, species
def plotter(df, xAxis, xAction, yAxis):
  #First, turn the data set into an easy to interpret table, of only modern data
  cleanDataSet = cleanModernDataTable(df)
  #cleanDataSet = cleanDataSet[cleanDataSet['ForestType']=='Hemlock']
  cleanDataSet = cleanDataSet[(cleanDataSet['ForestType']=='Hemlock') | (cleanDataSet['ForestType'] == 'HemlockHardwood-BB') | (cleanDataSet['ForestType'] == 'Hemlock-BB')]

  dataList = list(set(cleanDataSet[yAxis])) #Set of the yAxis parameters become the keys
  SumDict = dict.fromkeys(dataList,0) #The 0 initializes the list at 0
  CountDict = dict.fromkeys(dataList,0)
  AvgDict = dict.fromkeys(dataList,0)
  for index, row in cleanDataSet.iterrows():
    yVal = row[yAxis] #The will represent the individual value of the ie, species
    xSum = float(row[xAxis])
    SumDict[yVal] += xSum #Increment the DBH sum,
    CountDict[yVal] += 1 #Increment the count

  for key in SumDict: #Create the averages
    AvgDict[key] = SumDict[key] / CountDict[key]

  cd = defaultdict(list) #This combines the lists
  for d in (SumDict, CountDict, AvgDict):
    for key, value in d.items():
      cd[key].append(value)

  values = [elem[xAction] for elem in cd.values()] #The xAxis parameter is used here to determine sum, count, or average

  fig, ax = plt.subplots()
  y_pos = np.arange(len(cd.keys()))
  ax.barh(y_pos, values, align='center')
  ax.set_yticks(y_pos, labels=cd.keys())
  ax.invert_yaxis()  # labels read top-to-bottom
  ax.set_xlabel(xAxis)
  ax.set_title('')


#display(cleanModernDataTable(treedat))
plotter(treedat, 'ba', 0, 'Species')



'''

def plotAverages(dataFrame): #Creates a dictionary of values by plot from given dataset
    #Values are sum of diameter by plot, sum of ba by plot, tree count per plot, dbh avg per plot, ba avg per plot
    plotAreaSquareMeters = 225 #Value given to me by Megan Napoli, 15x15 meter plots
    plotAreaAcres = plotAreaSquareMeters/4047
    plotCount = dataFrame['Plot'].nunique()
    plot = [0]*plotCount
    treeCount = [0]*plotCount
    DBHSum = [0]*plotCount
    baSum = [0]*plotCount
    DBHAvg = [0]*plotCount
    baAvg = [0]*plotCount
    tpa = [0]*plotCount
    plotSize = 1/plotAreaAcres
    forestType = ['']*plotCount
    col = ['Plot', 'TreeCount', 'DBHSum', 'DBHAvg','baSum', 'baAvg', 'baCount', 'ef', 'ForestType']

    indexVal = 0
    #Double nested for loop. Will loop over the plots and individual tree data
    for i in range(1,(plotCount+1),1):
        for j in range(len(dataFrame[dataFrame['Plot']==i])):
            if(dataFrame['Year'][indexVal] == 2018): #We are only looking for 2021/2022 data
              #We are only looking for the most recent data
                indexVal+=1
                continue
            else:
                if(not(math.isnan(dataFrame['DBHInches'][indexVal]))):
                  #We do (i-1) because the plots are referenced at '1' and arrays are 0 referenced
                    DBHSum[i-1] += dataFrame['DBHInches'][indexVal] #DBHSum
                    baSum[i-1] += dataFrame['ba'][indexVal] #Basal Area Sum
                #QUESTION!: If the DBH is na, what should I do, still increment the tree count?
                #This will bring down the average diameter. To determine.
                treeCount[i-1] +=1
                indexVal+=1
    for i in range(plotCount):
        DBHAvg[i] = DBHSum[i]/treeCount[i]
        baAvg[i] = baSum[i]/treeCount[i]
        forestType[i] = dataFrame['Plot.Type'][dataFrame[dataFrame['Plot']==(i+1)].index[0]]
        plot[i] = (i+1)
        tpa[i] = plotSize * treeCount[i]

    returnTable = {'Plot': plot, 'DBHSum': DBHSum, 'baSum': baSum, 'TreeCount': treeCount, 'DBHAvg': DBHAvg, 'baAvg': baAvg, 'tpa': tpa, 'ForestType':  forestType}
    returnTableDF = pd.DataFrame.from_dict(returnTable, orient = 'index')
    returnTableDF = returnTableDF.transpose()
    return returnTableDF
#display(plotAverages(treedat))

'''

'''
def plotAverages2018(dataFrame):
  plotCount = dataFrame[dataFrame['Year']==2018]['Plot'].nunique()
  plotAvgs = np.zeros((plotCount, 5))
  DBHSum = [0]*plotCount
  baSum = [0]*plotCount
  treeCount = [0]*plotCount
  DBHAvg = [0]*plotCount
  baAvg = [0]*plotCount
  tpa = [0]*plotCount
  plot = [0]*plotCount
  forestType = ['']*plotCount
  plotAvgsReference = ['DBHSum', 'baSum', 'treeCount', 'DBHAvg', 'baAvg', 'ForestType']

  indexVal = 0
  for i in range(1,(plotCount+1),1):
      for j in range(len(dataFrame[dataFrame['Plot']==i])):
        if(dataFrame['Year'][indexVal] == 2022): #We are only looking for 2018 data
              #We are only looking for the most recent data
                indexVal+=1
                continue
        else:
          if(not(math.isnan(dataFrame['DBHInches'][indexVal]))):
            #We do (i-1) because the plots are referenced at '1' and arrays are 0 referenced
            DBHSum[i-1] += dataFrame['DBHInches'][indexVal] #DBHSum
            baSum[i-1] += dataFrame['ba'][indexVal] #Basal Area Sum
            treeCount[i-1] +=1
                #QUESTION!: If the DBH is na, what should I do, still increment the tree count?
                #This will bring down the average diameter. To determine.
            indexVal+=1

  for i in range(plotCount):
      DBHAvg[i] = DBHSum[i]/treeCount[i]
      baAvg[i] = baSum[i]/treeCount[i]
      forestType[i] = dataFrame['Plot.Type'][dataFrame[dataFrame['Plot']==(i+1)].index[0]]
      plot[i] = i+1
      tpa[i] = plotAreaAcres * (1/treeCount[i])

  returnTable = {'DBHSum': DBHSum, 'baSum': baSum, 'TreeCount': treeCount, 'DBHAvg': DBHAvg, 'baAvg': baAvg, 'ForestType':  forestType}
  returnTable = pd.DataFrame.from_dict(returnTable)
  return returnTable
'''